get.x <-
function(tsObj) {
    ### figure out the limits and step size along the x axis
    f = frequency(tsObj)
    s = start(tsObj)
    if (f == 1) {
      start.x = s[1]
      step.x = 1
      end.x = start.x + length(tsObj) - 1
    }
    else {
      step.x = 1/f
      start.x = s[1] + (s[2] - 1) * step.x
      end.x = start.x + step.x * (length(tsObj) - 1)
    }

    x = seq(start.x, end.x, by = step.x)
    x.units = unit(x, "native")
    list(x = x, x.units = x.units)
}

get.x2 <-
  function(tsObj) {
    ### figure out the limits and step size along the x axis
    f = frequency(tsObj)
    s = start(tsObj)
    if (f == 1) {
      start.x = s[1]
      step.x = 1
      end.x = start.x + length(tsObj) - 1
    }
    else {
      step.x = 1/f
      start.x = s[1] + (s[2] - 1) * step.x
      end.x = start.x + step.x * (length(tsObj) - 1)
    }

    x = seq(start.x, end.x, by = step.x)
    x = order(x)
    x = x/max(x)
    x.units = unit(x, "native")
    list(x = x, x.units = x.units)
  }

get.line.coords <-
function(vars.decomp, vpName, lineGrobName) {
    decomp = vars.decomp$decompVars
    seekViewport(vpName)
    line = getGrob(decomp$tree, lineGrobName)
    line.y = convertUnit(line$y, attr(line$y[1], "unit"), valueOnly = TRUE)
    line.vp.yrange = current.viewport()$yscale
    line.y.npc = (line.y - line.vp.yrange[1]) / diff(line.vp.yrange)
    line.y.parent = switch(vpName,
                           season = decomp$props["remainder"] +
                                      line.y.npc * decomp$props["seasonal"],
                           random = line.y.npc * decomp$props["remainder"],
                            trend = line.y.npc * decomp$props["trend"] +
                                      decomp$props["seasonal"] +
                                      decomp$props["remainder"])
    line.x = convertUnit(line$x, "native", valueOnly = TRUE)
    line.vp.xrange = current.viewport()$xscale
    line.x.npc = (line.x - line.vp.xrange[1]) / diff(line.vp.xrange)
    x.parent = line.x.npc

    list(line.y = line.y, line.vp.yrange = line.vp.yrange,
         line.y.npc = line.y.npc, line.y.parent = line.y.parent,
         line.x = line.x, line.vp.xrange = line.vp.xrange,
         line.x.npc = line.x.npc, x.parent = x.parent,
         line.col = line$gp$col)
}



add.line.plots.vp <-
function(vars.decomp, vpName, lineCol = "red",
                             name = paste(vpName, "copy", sep = ".")) {
    z = get.line.coords(vars.decomp, vpName, paste(vpName, "Line", sep = ""))
    lineCopy = linesGrob(unit(z$x.parent, "npc"),
                         unit(z$line.y.parent, "npc"),
                         name = name,
                         vp = vpPath("parent", "plots"),
                         gp = gpar(col = lineCol))
    updated.tree = addGrob(vars.decomp$decompVars$tree, lineCopy)
    vars.decomp$decompVars$tree = updated.tree
    vars.decomp
}



newdevice <-
function(width, height, ...) {

    if ("package:shiny" %in% search()){
      # we should let shiny to set their default graphics device
      # setting any width and height here force shiny popup a new window to you

      return()
    }
    # The windows device works fine (for now), only attempt to speed up
    # any other devices that we're going to be using.
    # We speed them up by getting rid of bufferring.
    if ("Acinonyx" %in% rownames(installed.packages())) {
        # Acinonyx uses pixels rather than inches, convert inches to
        # pixels to determine dims. Assume 90 dpi.
        width.in <- round(width * 90)
        height.in <- round(height * 90)
        Acinonyx::idev(width = width.in, height = height.in)
    } else {
        # i.e. if NOT "Windows"
        if (.Platform$OS.type != "windows") {
            # There are three variants of the cairo-based device:
            #
            # type = "nbcairo" has no buffering.
            # type = "cairo" has some buffering, and supports dev.hold and dev.flush.
            # type = "dbcairo" buffers output and updates the screen about every 100ms (by default).
            # options(X11updates = .1)
            #
            # Could explore the option of using cross-platform "Cairo" device...
            if ("cairoDevice" %in% rownames(installed.packages())) {
                cairoDevice::Cairo(width = width, height = height, ...)
            } else {
                warning("We suggest you install the `cairoDevice` package for better animations")
                X11(width = width, height = height, type = "cairo", ...)
            }

            # We use a buffered device as otherwise repainting when the window is exposed
            # will be slow. See ?X11()
            # X11(width = width, height = height, type = "cairo", ...)

        } else { 
            dev.new(width = width, height = height, ...)
        }
    }
}



###  We force any plot to hold and flush itself
drawImage <-
 function(image) {
  if ("Acinonyx" %in% rownames(installed.packages()))
      plot.new()
  # Draws current image in device.
  grid.newpage()
  grid.draw(image)
}


###  The dev.hold() and dev.flush() functions hold and flush frames.
###  Moreover, they are part of the grDevices package, which is
###  included in R by default. For non-windows graphics devices
###  that may or may not come with "double buffering", holding
###  and flushing an image for every iteration allows us to overcome
###  the problem of "flickering".

pauseImage <-
function(image, pause = 1) {
  for (i in 1:pause) {
      if (exists("dev.hold"))
          dev.hold(1)
      drawImage(image)
      if (exists("dev.flush"))
          dev.flush(1)
  }
}



rmGrobs <-
function(image, grobs) {
  for (i in grobs) {
    if (i %in% childNames(image)) {
      image <- removeGrob(image, gPath(i))
    }
  }
  image
}

